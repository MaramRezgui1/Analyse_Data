# -*- coding: utf-8 -*-
"""Analyse_Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eEyxlGwwuBHFswTncXAZefnubkQsuq38
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("/content/Customer-Churn-Records.csv")

# Print the DataFrame
print(df)

df.info()

df.shape

# Check for missing values in each column
missing_values = df.isnull().sum()
missing_values

df.describe().T

# Calculate the absolute percentage difference between mean and median for numerical columns only
numerical_cols = df.select_dtypes(include=['float', 'int']).columns
abs((df[numerical_cols].mean() - df[numerical_cols].median())/df[numerical_cols].mean())*100

"""-Cette cellule calcule la différence en pourcentage absolu entre la moyenne et la médiane pour chaque colonne numérique. Une différence importante peut indiquer une distribution asymétrique ou la présence de valeurs aberrantes. Par exemple, une grande différence pour la colonne 'Balance' pourrait suggérer qu'il y a des clients avec des soldes très élevés ou très bas qui influencent la moyenne."""

# summary information on the non-numeric columns

df.describe(include='object')

# Checking for the number of unique values in each column

for col in df.columns:
    unique_count = df[col].nunique()
    print(col + " has " + str(unique_count) + " unique values")

# prompt: utliser boxplot

import matplotlib.pyplot as plt
df.boxplot(figsize=(25,10))
plt.show()

"""


* Ce boxplot montre la distribution des données pour toutes les colonnes. Les lignes dans les boîtes représentent la médiane, tandis que les points au-delà des "moustaches" sont des valeurs aberrantes. On peut observer que les colonnes 'Balance' et 'EstimatedSalary' ont des valeurs aberrantes, ce qui pourrait influencer l'analyse.

"""

df.drop(columns=['RowNumber','CustomerId']).boxplot(figsize=(20,10))

"""

*   En retirant les colonnes 'RowNumber' et 'CustomerId', qui ne sont pas pertinentes pour l'analyse, le boxplot devient plus lisible. On peut voir des valeurs aberrantes dans les colonnes 'CreditScore', 'Age', 'Balance', et 'EstimatedSalary'.


"""

df[["CreditScore", "Age"]].boxplot()

"""* En se concentrant sur les colonnes 'CreditScore' et 'Age', on peut observer
que les âges des clients sont assez dispersés avec des valeurs aberrantes possibles aux extrêmes. De plus, la majorité des scores de crédit se situent entre 400 et 800, avec quelques valeurs aberrantes plus élevées ou plus basses.
"""

df[['Age']].boxplot()

"""
* Le boxplot pour l'âge montre une distribution de clients allant de 18 à 92 ans, avec une concentration plus forte entre 20 et 60 ans. Il y a aussi quelques valeurs aberrantes à des âges très élevés.


"""

df[['CreditScore']].boxplot()

"""

*   Le boxplot pour le score de crédit montre que la plupart des scores se situent entre 400 et 800, avec des valeurs aberrantes en dessous de 400 et au-dessus de 800.


"""

df["Exited"].value_counts()

"""* Cette cellule affiche le nombre de clients qui sont restés (0) et qui ont
   quitté (1) la banque. Cela donne un aperçu de la répartition des clients retenus et perdus.
"""

sns.countplot(x="Exited", data=df)
plt.show()

"""

* Le countplot montre visuellement la distribution des clients restés et partis. On peut observer que plus de clients sont restés que ceux qui ont quitté la banque.
"""

num_retained= df[df.Exited==0].shape[0]
num_churned=df[df.Exited==1].shape[0]
print("num_retained: ",(num_retained/(num_retained + num_churned))*100,"% stayed with the company")
print("num_churned: ",(num_churned/(num_retained + num_churned))*100 ,"% left the company")

"""* Cette cellule calcule et affiche le pourcentage de clients retenus et perdus. Par exemple, si 80% des clients sont restés et 20% ont quitté, cela peut indiquer des tendances dans la fidélisation des clients."""

sns.countplot(x="Gender", hue="Exited", data=df)
plt.show()

"""-
malgre que les femmes sont minoritaires dans le lot des donnees on remarque que le nombre des femmes qui quittent est superieur a celui des hommes .






*  

"""

sns.countplot(x="Geography", hue="Exited", data=df)
plt.show()

pd.crosstab(df["Geography"], df["Exited"],margins=True)

"""- on remaque que les allemands quittent plus que les autres nationalites


"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

sns.countplot(x="Age", hue="Exited", data=df)
plt.show()

df["Age"].hist(bins=200);

"""-On remarque que l'histogramme de la variable age suit loi de khi2

-On remarque que l'histogramme de la variable age des lients qui quittent est decale vers les grands valeurs

"""

pd.crosstab(df["Age"], df["Exited"],margins=True).T

sns.countplot(x="HasCrCard", hue="Exited", data=df)
plt.show()

"""* Ce graphique montre la distribution des clients qui sont restés (Exited = 0) et qui ont quitté (Exited = 1) la banque en fonction de leur possession d'une carte de crédit (HasCrCard = 1 signifie qu'ils ont une carte de crédit, HasCrCard = 0 signifie qu'ils n'en ont pas).

"""

pd.crosstab(df["HasCrCard"], df["Exited"],margins=True)

"""

* En analysant le tableau, nous observons que parmi les clients sans carte de crédit (HasCrCard = 0), 2332 sont restés (Exited = 0) et 613 ont quitté (Exited= 1), soit un total de 2945 clients.
* Parmi les clients avec une carte de crédit (HasCrCard = 1), 5630 sont restés (Exited = 0) et 1425 ont quitté (Exited = 1), soit un total de 7055 clients.

"""

sns.countplot(x="IsActiveMember", hue="Exited", data=df)
plt.show()

"""* Ce graphique montre la distribution des clients qui sont restés (Exited = 0) et qui ont quitté (Exited = 1) la banque en fonction de leur statut de membre actif (IsActiveMember = 1 signifie qu'ils sont membres actifs, IsActiveMember = 0 signifie qu'ils ne sont pas membres actifs)."""

pd.crosstab(df["IsActiveMember"], df["Exited"],margins=True)

"""* Parmi les clients inactifs (IsActiveMember = 0), 3546 sont restés (Exited =0) et 1303 ont quitté (Exited = 1), soit un total de 4849 clients.
Parmi les clients actifs (IsActiveMember = 1), 4416 sont restés (Exited = 0) et 735 ont quitté (Exited = 1), soit un total de 5151 clients.
"""

# prompt: i want to remove column RowNumber

df.drop(columns=["RowNumber"], inplace=True)

"""-on remarque que si le client n'estpas actif alors il risque plus de quitter le service qu'un client actif"""

df.select_dtypes(exclude=object).columns

numerical_features=['CreditScore', 'Age', 'Tenure', 'Balance',
       'NumOfProducts', 'HasCrCard', 'IsActiveMember', 'EstimatedSalary',
       'Exited', 'Complain', 'Satisfaction Score', 'Point Earned']

len(numerical_features)

fig ,ax =plt.subplots(6,2,figsize=(30,30))
df[df.Exited==0][numerical_features].hist(bins=20,color='blue',ax=ax)
df[df.Exited==1][numerical_features].hist(bins=20,color='red',ax=ax)
plt.show()

"""

* Les histogrammes montrent la distribution des caractéristiques numériques pour les clients qui sont restés (Exited = 0, en bleu) et pour ceux qui ont quitté (Exited = 1, en rouge) la banque.
* CreditScore : La distribution des scores de crédit pour les clients quittant peut être comparée à celle des clients restants pour identifier des tendances ou des différences significatives.
* Age : L'âge des clients quittant et restants peut montrer si des groupes d'âge spécifiques sont plus susceptibles de quitter la banque.
* Tenure : La durée de relation avec la banque peut être analysée pour voir si les clients avec une tenure plus courte ou plus longue ont un taux de churn plus élevé.
* Balance : Les balances des comptes peuvent indiquer si les clients avec des soldes spécifiques sont plus susceptibles de quitter.
* NumOfProducts : Le nombre de produits détenus par les clients peut montrer une corrélation entre la diversification des produits et le churn.
* EstimatedSalary : Le salaire estimé des clients peut être analysé pour voir s'il y a une différence notable entre ceux qui quittent et ceux qui restent.

"""

df.CustomerId.hist()

df.RowNumber.hist()

df_clean=df.drop(columns=['RowNumber','CustomerId','Surname'])

pd.plotting.scatter_matrix(df_clean,figsize=(20,20),c = df['Exited']);
plt.show()

#check missing values and sum of unique values
def data_overview():
    print("Rows :  " , df.shape[0])
    print("Columns:  " , df.shape[1] )
    print('Missing Value number : ' , df.isnull().sum().values.sum())
    print('\nUnique values' , df.nunique())
data_overview()

#no missing value

df.count()

"""Now we know:

* We have 10,000 customers, with more males than females.
* All the customers are from three countries, mostly from France.
* The average credit score is 650.5.
* The age distribution spans 70 years, with an average age of 38.9.
* The average balance is 76,485.8, and the average estimated salary is 100,090.
* The average tenure is five months.
* There are four card types, Diamond cards are the most common card type, and * each customer has an average of 0.7 credit cards.
* Each customer has used an average of 1.5 products, and over half of them are active members.
* The average satisfaction score is 3.



"""

# Count the number of customers who churned (Exited = 1)
churned_count = (df['Exited'] == 1).sum()

# Total number of customers
total_customers = df.shape[0]

# Calculate churn rate
churn_rate = (churned_count / total_customers) * 100

print(f"Churn rate: {churn_rate:.2f}%")

# pie chart data
labels = ['Churned Customers', 'Retained Customers']
sizes = [churned_count, total_customers - churned_count]
colors = ['salmon', 'teal']

# Create the pie chart
plt.figure(figsize=(6, 6))
plt.pie(sizes, labels=labels, autopct="%1.1f%%", startangle=140, colors=colors)
plt.title(f'Churn Rate: {churn_rate:.2f}%')
plt.axis('equal')

# Display pie chart
plt.show()

# Count the number of churned customers by gender
churn_count_by_gender = df[df['Exited'] == 1]['Gender'].value_counts()

# Define a custom color palette
custom_palette = ["coral", "seagreen"]

# Create a pie chart for the churned customers
plt.figure(figsize=(8, 8))
plt.pie(churn_count_by_gender, labels=churn_count_by_gender.index, colors=custom_palette,
        autopct='%1.1f%%', startangle=140)

# Set the title
plt.title('Proportion of Churned Customers by Gender')

# Show the plot
plt.show()

# Define age bins and labels
age_bins = [15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 100]
labels = ['15-20', '20-25', '25-30', '30-35', '35-40', '40-45', '45-50', '50-55', '55-60', '60-65', '65-70', '70+']

# Create age groups based on the bins
df['Age_Group'] = pd.cut(df['Age'], bins=age_bins, labels=labels, right=False)

# Calculate churn rate for each age group
churn_by_age = df.groupby('Age_Group')['Exited'].mean() * 100
churn_by_age.index = labels

# Plot age distribution with spacing between bars
plt.figure(figsize=(12, 6))

# Create a color palette from viridis
palette = sns.color_palette("viridis", len(labels))

# Plot the histogram manually to set colors and spacing
bar_width = 0.8  # Width of the bars, reduced for spacing
for i, label in enumerate(labels):
    age_group_count = df[df['Age_Group'] == label].shape[0]
    plt.bar(i, age_group_count, width=bar_width, color=palette[i])

# Set x-ticks and labels
plt.xticks(np.arange(len(labels)), labels)

# Create the secondary y-axis for the churn rate
ax2 = plt.gca().twinx()
ax2.plot(churn_by_age.index, churn_by_age.values, marker='o', color='tomato', label='Churn Rate (%)')
ax2.set_ylabel('Churn Rate (%)')
# Annotate churn rate percentages
for i, txt in enumerate(churn_by_age.values):
    ax2.annotate(f'{txt:.2f}%',
                 (i, txt),
                 textcoords="offset points",
                 xytext=(0,10),
                 ha='center',
                 bbox=dict(boxstyle="round,pad=0.3", edgecolor='black', facecolor='white'))


# Set labels and title
plt.title('Age Distribution with Churn Rate', pad=20)
plt.xlabel('Age Group')
plt.ylabel('Number of Customers')

# Show legend for the churn rate
ax2.legend(loc='upper right')

plt.show()

# Calculate the number of customers for each Geography
geography_counts = df['Geography'].value_counts()

# Plot the distribution of Geography
plt.figure(figsize=(10, 6))
ax = sns.barplot(x=geography_counts.index, y=geography_counts.values, palette='viridis')

# Annotate the numbers on the bars
for i, count in enumerate(geography_counts.values):
    ax.text(i, count + 0.05 * max(geography_counts.values), str(count), ha='center', fontsize=12, color='black')

# Set title and labels
plt.title('Number of Customers by Geography', pad=20)
plt.xlabel('Geography')
plt.ylabel('Number of Customers')

# Show the plot
plt.show()

import geopandas as gpd
import matplotlib.patheffects as path_effects

#Calculate churn rate by country
churn_by_country = df.groupby('Geography')['Exited'].mean() * 100

#Load the shapefile
world = gpd.read_file('countries.geo.json')

#Merge the churn rate data with the shapefile
world = world.merge(churn_by_country, left_on='name', right_index=True)

#Plot the map
fig, ax = plt.subplots(1, 1, figsize=(15, 10))
world.boundary.plot(ax=ax, linewidth=1)  # Add borders
world.plot(column='Exited', cmap='OrRd', figsize=(15, 10), legend=True, ax=ax, edgecolor='black')

# Add labels for country names and churn rates
for idx, row in world.iterrows():
    text = plt.text(row.geometry.centroid.x, row.geometry.centroid.y,
                    f'{row["name"]}\n{row["Exited"]:.2f}%',
                    horizontalalignment='center', fontsize=8, color='black')
    text.set_path_effects([path_effects.Stroke(linewidth=3, foreground='white'),
                           path_effects.Normal()])

plt.title('Churn Rate by Country')
plt.show()

# Group data by age group and geography, and calculate churn rate
churn_rate_data = df.groupby(['Age_Group', 'Geography'])['Exited'].mean().reset_index()

# Create pivot table
pivot_table = churn_rate_data.pivot_table(index='Age_Group', columns='Geography', values='Exited')

# Plot the heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(pivot_table, annot=True, cmap='YlGnBu', fmt=".2f", linewidths=0.5)
plt.title('Churn Rate by Age Group and Geography', pad=20)
plt.xlabel('Geography', labelpad=25)
plt.ylabel('Age Group')
plt.show()

df['Tenure'].value_counts().sort_index()

# Define tenure bins
tenure_bins = [-0.5, 0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5, 10.5]

# Create tenure groups based on the bins
df['Tenure_Group'] = pd.cut(df['Tenure'], bins=tenure_bins, labels=False)

# Calculate churn rate for each tenure group
churn_by_tenure = (df.groupby('Tenure_Group')['Exited'].mean() * 100).fillna(0)  # Fill NaN values with 0

# Plot tenure distribution
plt.figure(figsize=(10, 6))
ax = sns.histplot(df['Tenure'], bins=tenure_bins, kde=False, color='teal', alpha=0.5)
ax.set_ylabel('Number of Customers')

# Plot churn rate line
ax2 = ax.twinx()
ax2.plot(churn_by_tenure.index, churn_by_tenure.values, marker='o', color='tomato', label='Churn Rate (%)')
ax2.set_ylabel('Churn Rate (%)')
ax2.set_ylim(0, 100)  # Ensure the y-axis limit is from 0% to 100%

for i, txt in enumerate(churn_by_tenure.values):
    ax2.annotate(f'{txt:.2f}%', (churn_by_tenure.index[i], txt), textcoords="offset points", xytext=(0,10), ha='center')

# Set labels and title
plt.title('Tenure Distribution with Churn Rate', pad=20)
plt.xlabel('Tenure (Midpoint of Each Bin)', labelpad=20)
plt.ylabel('Churn Rate (%)')
ax.set_ylabel('Number of Customers')

# Show legend
lines, labels = ax.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax.legend(lines + lines2, labels + labels2, loc='upper right')

plt.show()

# Calculate the proportion of churned and non-churned customers for each card type
exit_by_card_type = df.groupby(['Card Type', 'Exited']).size().unstack()
exit_by_card_type['Total'] = exit_by_card_type.sum(axis=1)
exit_by_card_type['Churn Rate (%)'] = (exit_by_card_type[1] / exit_by_card_type['Total']) * 100

# Choose colors for different card types
colors = ['darksalmon', 'gold', 'whitesmoke', 'silver']

# Plot the stacked bar chart showing percentages
plt.figure(figsize=(10, 6))
bars = exit_by_card_type['Churn Rate (%)'].plot(kind='bar', color=colors, edgecolor='black')
plt.title('Churn Rate by Card Type', pad=20)
plt.xlabel('Card Type')
plt.ylabel('Churn Rate (%)')
plt.xticks(rotation=45)

# Display percentage labels
for bar in bars.patches:
    value = bar.get_height()
    # Check if the label is outside the plot area
    if value >= bar.get_height():
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() - 1, f'{value:.2f}%', ha='center', va='bottom')  # Adjust the y-coordinate
    else:
        plt.text(bar.get_x() + bar.get_width()/2, value + 1, f'{value:.2f}%', ha='center', va='bottom')

plt.show()

# Calculate the correlation matrix
corr_matrix = df_numeric = df.select_dtypes(include=['number']).corr()

# Select the correlation of 'Exited' with other variables
corr_with_exited = corr_matrix[['Exited']]

# Plot the heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(corr_with_exited, annot=True, cmap='coolwarm', vmin=-1, vmax=1)
plt.title('Correlation of Exited with Other Variables', pad=20)
plt.show()


#Correlation Values:
#The numbers in each cell represent the correlation coefficient between the variables.

#The value ranges from -1 to 1:
#1: Perfect positive correlation
#0: No correlation
#-1: Perfect negative correlation

# Calculate the total number of customers for each complaint status
total_customers_by_complain = df['Complain'].value_counts()

# Calculate the number of exited customers for each complaint status
exited_customers_by_complain = df[df['Exited'] == 1]['Complain'].value_counts()

# Create a DataFrame
churn_data = pd.DataFrame({
    'Total Customers': total_customers_by_complain,
    'Exited Customers': exited_customers_by_complain
}).fillna(0)

# Calculate the number of retained customers
churn_data['Retained Customers'] = churn_data['Total Customers'] - churn_data['Exited Customers']

# Ensure the index has correct string labels
churn_data.index = churn_data.index.map({1: 'Complain', 0: 'No Complain'})

# Plot the donut charts
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

colors = ["coral", "cadetblue"]

for i, (status, row) in enumerate(churn_data.iterrows()):
    ax = axes[i]
    wedges, texts, autotexts = ax.pie(
        [row['Exited Customers'], row['Retained Customers']],
        labels=None,
        autopct='%1.1f%%',
        startangle=90,
        colors=colors,
        wedgeprops=dict(width=0.3)
    )
    ax.set_title(f'{status} Customers')
    for text in texts:
        text.set_color('black')
    for autotext in autotexts:
        autotext.set_color('black')

# Add legend
fig.legend(wedges, ['Exited Customers', 'Retained Customers'], loc='center right', bbox_to_anchor=(1.1, 0.5))

plt.suptitle('Customer Churn and Retention by Complain Status')
plt.tight_layout(rect=[0, 0, 0.9, 1])
plt.show()

df['Satisfaction Score'].value_counts().sort_index()

# Calculate the proportion of churned and non-churned customers for Satisfaction Score
exit_by_Satisfaction_Score = df.groupby(['Satisfaction Score', 'Exited']).size().unstack(fill_value=0)
exit_by_Satisfaction_Score['Total'] = exit_by_Satisfaction_Score.sum(axis=1)
exit_by_Satisfaction_Score['Churn Rate (%)'] = (exit_by_Satisfaction_Score[1] / exit_by_Satisfaction_Score['Total']) * 100

# Define colors for different Satisfaction Scores
colors = ['red', 'salmon', 'gold', 'limegreen', 'green']

# Define the emoji labels for Satisfaction Scores
emoji_labels = {
    1: '😟1',  # Very dissatisfied
    2: '😐2',  # Neutral
    3: '😊3',  # Satisfied
    4: '😁4',  # Very satisfied
    5: '😍5'   # Extremely satisfied
}

# Replace numerical labels with emojis
exit_by_Satisfaction_Score.index = exit_by_Satisfaction_Score.index.map(emoji_labels)

# Plot the stacked bar chart showing percentages
plt.figure(figsize=(12, 8))
bars = exit_by_Satisfaction_Score['Churn Rate (%)'].plot(kind='bar', color=colors[:len(exit_by_Satisfaction_Score)], edgecolor='black')
plt.title('Churn Rate by Satisfaction Score')
plt.xlabel('Satisfaction Score', labelpad=15)
plt.ylabel('Churn Rate (%)')
plt.xticks(rotation=0)


for i, value in enumerate(exit_by_Satisfaction_Score['Churn Rate (%)']):
    plt.text(i, value/2, f'{value:.2f}%', ha='center', va='center')

plt.show()

# Calculate the total number of customers for each IsActiveMember status
total_customers_by_active_member = df['IsActiveMember'].value_counts()

# Calculate the number of exited customers for each IsActiveMember status
exited_customers_by_active_member = df[df['Exited'] == 1]['IsActiveMember'].value_counts()

# Create a DataFrame
churn_data = pd.DataFrame({
    'Total Customers': total_customers_by_active_member,
    'Exited Customers': exited_customers_by_active_member
}).fillna(0)

# Calculate the number of retained customers
churn_data['Retained Customers'] = churn_data['Total Customers'] - churn_data['Exited Customers']

# Ensure the index has correct string labels
churn_data.index = churn_data.index.map({1: 'Active Member', 0: 'Inactive Member'})

# Plot the donut charts
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

colors = ["coral", "cadetblue"]

for i, (status, row) in enumerate(churn_data.iterrows()):
    ax = axes[i]
    wedges, texts, autotexts = ax.pie(
        [row['Exited Customers'], row['Retained Customers']],
        labels=None,
        autopct='%1.1f%%',
        startangle=90,
        colors=colors,
        wedgeprops=dict(width=0.3)
    )
    for text in texts:
        text.set_color('black')
    for autotext in autotexts:
        autotext.set_color('black')

    # Add status label below the plot
    ax.text(0, -1.2, status, ha='center', fontsize=12, color='black')

# Hide the original titles
for ax in axes:
    ax.set_title('')

# Add legend
fig.legend(wedges, ['Exited Customers', 'Retained Customers'], loc='center right', bbox_to_anchor=(1.1, 0.5))

# Add an overarching title
plt.suptitle('Customer Churn and Retention by Active Member Status', y=1.05)
plt.tight_layout(rect=[0, 0, 0.9, 1])
plt.show()

# Calculate the total number of customers for each HasCrCard status
total_customers_by_crcard = df['HasCrCard'].value_counts()

# Calculate the number of exited customers for each HasCrCard status
exited_customers_by_crcard = df[df['Exited'] == 1]['HasCrCard'].value_counts()

# Create a DataFrame
churn_data = pd.DataFrame({
    'Total Customers': total_customers_by_crcard,
    'Exited Customers': exited_customers_by_crcard
}).fillna(0)

# Calculate the number of retained customers
churn_data['Retained Customers'] = churn_data['Total Customers'] - churn_data['Exited Customers']

# Ensure the index has correct string labels
churn_data.index = churn_data.index.map({1: 'Has Credit Card', 0: 'No Credit Card'})

# Plot the donut charts
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

colors = ["coral", "cadetblue"]

for i, (status, row) in enumerate(churn_data.iterrows()):
    ax = axes[i]
    wedges, texts, autotexts = ax.pie(
        [row['Exited Customers'], row['Retained Customers']],
        labels=None,
        autopct='%1.1f%%',
        startangle=90,
        colors=colors,
        wedgeprops=dict(width=0.3)
    )
    for text in texts:
        text.set_color('black')
    for autotext in autotexts:
        autotext.set_color('black')

    # Add status label below the plot
    ax.text(0, -1.2, status, ha='center', fontsize=12, color='black')

# Hide the original titles
for ax in axes:
    ax.set_title('')

# Add legend
fig.legend(wedges, ['Exited Customers', 'Retained Customers'], loc='center right', bbox_to_anchor=(1.1, 0.5))

# Add an overarching title
plt.suptitle('Customer Churn and Retention by Credit Card Ownership', y=1.05)
plt.tight_layout(rect=[0, 0, 0.9, 1])
plt.show()

# Calculate the proportion of churned and non-churned customers for each NumOfProducts
exit_by_NumOfProducts = df.groupby(['NumOfProducts', 'Exited']).size().unstack(fill_value=0)
exit_by_NumOfProducts['Total'] = exit_by_NumOfProducts.sum(axis=1)
exit_by_NumOfProducts['Churn Rate (%)'] = (exit_by_NumOfProducts[1] / exit_by_NumOfProducts['Total']) * 100

# Choose colors for different NumOfProducts
colors = ['lightcoral','indianred','firebrick','darkred']

# Plot the stacked bar chart showing percentages
plt.figure(figsize=(10, 6))
bars = exit_by_NumOfProducts['Churn Rate (%)'].plot(kind='bar', color=colors[:len(exit_by_NumOfProducts)], edgecolor='black')
plt.title('Churn Rate by Num of Products', pad=20)
plt.xlabel('Num of Products')
plt.ylabel('Churn Rate (%)')
plt.xticks(rotation=0)


# Display percentage labels
for i, value in enumerate(exit_by_NumOfProducts['Churn Rate (%)']):
    plt.text(i, value + 1, f'{value:.2f}%', ha='center', va='bottom')

plt.show()

df['NumOfProducts'].value_counts().sort_index()

# Calculate the proportion of churned and non-churned customers for Point Earned
exit_by_points = df.groupby('Point Earned')['Exited'].mean() * 100

# plotting a line chart
plt.figure(figsize=(10, 6))
exit_by_points.plot(marker='o', color='seagreen', linestyle='-')
plt.title('Churn Rate by Points Earned', pad=20)
plt.xlabel('Points Earned', labelpad=15)
plt.ylabel('Churn Rate (%)')
plt.grid(True)
plt.show()

# Define salary bins and labels
salary_bins = [0, 20000, 40000, 60000, 80000, 100000, 120000, 140000, 160000, 180000, 200000]
labels = ['0-20k', '20k-40k', '40k-60k', '60k-80k', '80k-100k', '100k-120k', '120k-140k', '140k-160k', '160k-180k', '180k-200k']

# Create salary groups based on the bins
df['Salary_Group'] = pd.cut(df['EstimatedSalary'], bins=salary_bins, labels=labels, right=False)

# Calculate churn rate for each salary group
churn_by_salary = df.groupby('Salary_Group')['Exited'].mean() * 100

# Plot the churn rate by salary group
plt.figure(figsize=(12, 6))
ax = sns.barplot(x=churn_by_salary.index, y=churn_by_salary.values, palette="viridis", edgecolor='black')
plt.title('Churn Rate by Estimated Salary Group', pad =20)
plt.xlabel('Estimated Salary Group', labelpad=15)
plt.ylabel('Churn Rate (%)')

# Display percentage labels on the bars
for i, value in enumerate(churn_by_salary.values):
    plt.text(i, value + 0.5, f'{value:.2f}%', ha='center', va='bottom')

plt.show()

df['Salary_Group'].value_counts().sort_index()

# Create balance bins
balance_bins = pd.cut(df['Balance'], bins=10)

# Calculate churn rate for each balance bin
churn_by_balance = df.groupby(balance_bins)['Exited'].mean() * 100
balance_bin_centers = [bin.mid for bin in churn_by_balance.index]

# Plot the distribution of Balance
plt.figure(figsize=(10, 6))
ax = sns.histplot(df['Balance'], bins=10, kde=False, color='skyblue', alpha=0.5)

# Plot the churn rate line
ax2 = ax.twinx()
ax2.plot(balance_bin_centers, churn_by_balance.values, marker='o', color='tomato', label='Churn Rate (%)')
ax2.set_ylabel('Churn Rate (%)')
ax2.set_ylim(0, 100)  # Set the y-axis limit for churn rate to 0-100%

# Annotate churn rate values on the plot
for i, txt in enumerate(churn_by_balance.values):
    ax2.annotate(f'{txt:.2f}%', (balance_bin_centers[i], txt), textcoords="offset points", xytext=(0,10), ha='center')

# Set title and axis labels
plt.title('Distribution of Balance with Churn Rate')
ax.set_xlabel('Balance')
ax.set_ylabel('Number of Customers')

# Show legend
lines, labels = ax.get_legend_handles_labels()
lines2, labels2 = ax2.get_legend_handles_labels()
ax.legend(lines + lines2, labels + labels2, loc='upper right')

# Show the plot
plt.show()

bin_size = 25000

bins = np.arange(0, df['Balance'].max() + bin_size, bin_size)


df['bins'] = pd.cut(df['Balance'], bins=bins)
bin_counts = df['bins'].value_counts().sort_index()

print(bin_counts)

# Selecting variables to analyze
selected_vars = ['CreditScore','Age', 'NumOfProducts', 'Balance','EstimatedSalary','Exited']

# Creating pairplot with selected variables
sns.pairplot(data=df[selected_vars], hue='Exited')
plt.show()

cleaned_file_path = '/content/Cleaned-Customer-Churn-Records.csv'
df.to_csv(cleaned_file_path, index=False)